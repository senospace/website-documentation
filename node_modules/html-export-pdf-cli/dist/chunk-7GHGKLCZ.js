import {
  replaceExt
} from "./chunk-JJ7QCWYH.js";
import {
  createProgress
} from "./chunk-SIUHHSBY.js";
import {
  writeFileSafe
} from "./chunk-N6EY6WOW.js";
import {
  isValidUrl
} from "./chunk-6ROE5BAT.js";
import {
  collectParameters,
  commaSeparatedList
} from "./chunk-VLPX72JG.js";
import {
  Printer
} from "./chunk-5IJCBM7K.js";
import {
  dim,
  green,
  red
} from "./chunk-AEIYKZGE.js";
import {
  HTML_EXPORT_PDF_CLI
} from "./chunk-ZT5ILKFF.js";
import {
  package_default
} from "./chunk-YPFOPOKA.js";

// src/commands/htmlExportPdf/htmlExportPdf.ts
import path from "node:path";
import { accessSync, constants } from "node:fs";
import process2 from "node:process";
import fg from "fast-glob";

// src/commands/runner.ts
import process from "node:process";
import { program } from "commander";

// src/commands/htmlExportPdf/createHtmlExportPdf.ts
function createHtmlExportPdf(program2) {
  program2.arguments("[inputs...]").option("-i, --inputs <inputs>", "Input one or more local or online paths", collectParameters, []).option("-o, --outFile [outFile]", "Output file name(default: {input}.pdf)").option("--outDir [outDir]", "Output directory(default: process.cwd())").option("--headless [headless]", "Whether to run the browser in headless mode(default: 'new')", (v) => {
    if (v === "false")
      return false;
    if (v === "true")
      return true;
    return v;
  }, "new").option("--scale <scale>", "Scales the rendering of the web page. Amount must be between 0.1 and 2(default: 1)", (v) => Number(v), 1).option("--headerTemplate <headerTemplate>", "HTML template for the print header").option("--footerTemplate <footerTemplate>", "HTML template for the print footer").option("--preferCSSPageSize", "Give any CSS @page size declared in the page priority over what is declared in the width or height or format option(default: false)", false).option("--printBackground", "Set to print background graphics(default: false)", false).option("--omitBackground", "Hides default white background and allows generating PDFs with transparency(default: false)", false).option("--pageRanges <pageRanges>", "Paper ranges to print, e.g. 1-5, 8, 11-13").option("-m, --margin <margin>", "Set the PDF margins. e.g. top=10,bottom=10,left=10,right=10").option("-l, --landscape", "Whether to print in landscape orientation(default: false)", false).option("-s, --page-size <size>", "Print to Page Size", "letter").option("-w, --width <width>", "Print to Page Width").option("-h --height <height>", "Print to Page Height").option("-t, --timeout <ms>", "Set a max timeout of ms").option("-x, --html", "output html file").option("-b, --blockLocal", "Disallow access to filesystem for local files(default: false)", false).option("-r, --blockRemote", "Disallow requests to remote servers(default: false)", false).option("--outlineContainerSelector <outlineContainerSelector>", "Specify an outline container selector").option("--allowedPaths <allowedPaths>", "Only allow access to given filesystem paths, repeatable", collectParameters, []).option("--allowedDomains <allowedDomains>", "Only allow access to given remote domains, repeatable", collectParameters, []).option("--ignoreHTTPSErrors", "Whether to ignore HTTPS errors during navigation(default: false)", false).option("--outline-tags <tags>", "Add outlines (bookmarks) to PDF", commaSeparatedList, ["h1", "h2", "h3", "h4", "h5", "h6"]).option("--additional-scripts <additionalScripts>", "additional script tags to the HTML document", collectParameters, []).option("--additional-styles <additionalStyles>", "additional style tags to the HTML document", collectParameters, []).option("--browserEndpoint", "Use a remote Chrome server with browserWSEndpoint").option("--browserArgs <browserArgs>", "Launch Chrome with comma separated args", commaSeparatedList).option("--media <media>", "Emulate print or screen media, defaults to print(default: 'print')", "print").option("-d, --debug", "Debug").option("--warn", "Enable warning logs").action(htmlExportPdf);
}

// src/commands/runner.ts
function registerCommands(cliInstance, programName) {
  switch (programName) {
    case HTML_EXPORT_PDF_CLI:
      createHtmlExportPdf(cliInstance);
      break;
    default:
      process.stdout.write(red("no command name"));
      break;
  }
}
function beforeParse(cliInstance) {
  cliInstance.version(package_default.version);
}
function afterParse(cliInstance) {
  if (!process.argv.slice(2).filter(Boolean).length)
    cliInstance.outputHelp();
}
function runCli(programName) {
  registerCommands(program, programName);
  beforeParse && beforeParse(program);
  program.parse(process.argv);
  afterParse && afterParse(program);
}

// src/commands/htmlExportPdf/htmlExportPdf.ts
async function htmlExportPdf(args, options) {
  const inputArr = options.inputs.length ? options.inputs : args ?? [];
  if (!inputArr.length) {
    process2.stdout.write(red("You must include an input path"));
    process2.exit(1);
  }
  const dir = process2.cwd();
  const globPaths = inputArr.reduce((acc, inputPath) => {
    if (!isValidUrl(inputPath)) {
      if (![".htm", ".html", ".xhtml"].includes(path.extname(inputPath))) {
        process2.stdout.write(red(`${inputPath} is must a html or xhtml file`));
        process2.exit(1);
      }
      try {
        accessSync(inputPath, constants.F_OK);
      } catch (e) {
        console.error(`${inputPath} Input cannot be found`, e);
        process2.exit(1);
      }
      const absolutePathArr = fg.sync([inputPath], {
        ignore: ["node_modules"],
        onlyFiles: true,
        cwd: dir,
        absolute: true
      });
      return [...acc, ...absolutePathArr.map((item) => `file://${item}`)];
    }
    return [...acc, inputPath];
  }, []);
  const isSingleFile = globPaths.length === 1;
  const progress = createProgress(isSingleFile);
  progress.start(globPaths.length);
  const printerOptions = {
    debug: options.debug,
    headless: options.headless,
    allowLocal: !options.blockLocal,
    allowRemote: !options.blockRemote,
    allowedPaths: options.allowedPaths,
    allowedDomains: options.allowedDomains,
    ignoreHTTPSErrors: options.ignoreHTTPSErrors,
    additionalScripts: options.additionalScripts,
    additionalStyles: options.additionalStyles,
    browserEndpoint: options.browserEndpoint,
    timeout: options.timeout,
    browserArgs: options.browserArgs,
    emulateMedia: options.media,
    enableWarnings: options.warn,
    outlineContainerSelector: options.outlineContainerSelector
  };
  const printer = new Printer(printerOptions);
  const getOutFileName = (inputPath) => {
    if (globPaths.length === 1 && options.outFile)
      return options.outFile.endsWith(".pdf") ? options.outFile : `${options.outFile}.pdf`;
    const baseName = path.basename(inputPath);
    const splitBaseName = baseName.split(":")[0];
    const hostName = new URL(inputPath).hostname;
    if (splitBaseName === hostName) {
      return `${hostName}.pdf`;
    }
    const filename = baseName.split("/").pop();
    if (!filename?.length)
      return `${baseName.split("/").filter(Boolean).join("_")}.pdf`;
    return replaceExt(path.basename(inputPath), ".pdf");
  };
  for (const inputPath of globPaths) {
    try {
      const outFileName = getOutFileName(inputPath);
      let output = path.join(dir, options.outDir ?? "", outFileName);
      let file;
      if (options.html) {
        file = await printer.html(inputPath).catch((e) => {
          console.error(e);
          process2.exit(1);
        });
        output = replaceExt(output, ".html");
      } else if (options.debug === true) {
        await printer.render(inputPath);
      } else {
        const format = options.pageSize;
        let margin = {};
        if (options.margin) {
          margin = options.margin.split(",").reduce((obj, item) => {
            const [key, value] = item.split("=");
            if (key === "top" || key === "bottom" || key === "left" || key === "right")
              obj[key] = value;
            return obj;
          }, {});
        }
        file = await printer.pdf(inputPath, {
          ...options,
          margin,
          format
        }).catch((e) => {
          console.error(e);
          process2.exit(1);
        });
      }
      if (file && output) {
        const isWrite = await writeFileSafe(output, file);
        if (isWrite) {
          progress.increment(1);
          isSingleFile && process2.stdout.write(`

 ${green("  \u2713 ")}${dim("Saved to ")} ${output}

`);
        } else {
          process2.exit(1);
        }
      } else if (file) {
        process2.stdout.write(file);
      }
      await printer.closePage(inputPath);
    } catch (error) {
      console.error(error);
    }
  }
  await printer.closeBrowser();
  progress.stop();
  !isSingleFile && process2.stdout.write(`

 ${green("  \u2713 ")}${dim("Saved to ")} ${path.join(dir, options.outDir ?? "")}

`);
  process2.exit(0);
}
var htmlExportPdf_default = htmlExportPdf;

export {
  htmlExportPdf,
  htmlExportPdf_default,
  createHtmlExportPdf,
  registerCommands,
  beforeParse,
  afterParse,
  runCli
};

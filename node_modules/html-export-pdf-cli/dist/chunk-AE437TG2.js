// src/core/outline.ts
import { decode } from "html-entities";
import { PDFArray, PDFDict, PDFHexString, PDFName, PDFNumber } from "pdf-lib";
function formatOutlineContainerSelector(outlineContainerSelector) {
  if (!outlineContainerSelector)
    return "";
  const selectors = outlineContainerSelector.split(/\s+/);
  const validSelectors = selectors.filter((selector) => selector);
  const formattedSelector = `${validSelectors.join(" ")} `;
  return formattedSelector;
}
async function getOutline(page, tags, outlineContainerSelector = "") {
  const preSelector = formatOutlineContainerSelector(outlineContainerSelector);
  return await page.evaluate((tags2, outlineSelector) => {
    const tagsToProcess = Array.from(document.querySelectorAll(outlineSelector)).reverse();
    const root = { children: [], depth: -1, parent: void 0 };
    let currentOutlineNode = root;
    const linkHolder = document.createElement("div");
    const body = document.querySelector("body");
    linkHolder.style.display = "none";
    body?.insertBefore(linkHolder, body.firstChild);
    while (tagsToProcess.length > 0) {
      const tag = tagsToProcess.pop();
      const orderDepth = tags2.indexOf(tag.tagName.toLowerCase());
      const dest = encodeURIComponent(tag.id);
      const hiddenLink = document.createElement("a");
      hiddenLink.href = `#${dest}`;
      linkHolder.appendChild(hiddenLink);
      if (orderDepth < currentOutlineNode.depth) {
        currentOutlineNode = currentOutlineNode.parent;
        tagsToProcess.push(tag);
      } else {
        const newNode = {
          // https://stackoverflow.com/questions/57551589/property-innertext-does-not-exist-on-type-element
          title: tag.innerText.trim(),
          destination: dest,
          children: [],
          depth: orderDepth,
          parent: void 0
        };
        if (orderDepth === currentOutlineNode.depth) {
          if (currentOutlineNode.parent) {
            newNode.parent = currentOutlineNode.parent;
            currentOutlineNode.parent.children.push(newNode);
          } else {
            newNode.parent = currentOutlineNode;
            currentOutlineNode.children.push(newNode);
          }
          currentOutlineNode = newNode;
        } else if (orderDepth > currentOutlineNode.depth) {
          newNode.parent = currentOutlineNode;
          currentOutlineNode.children.push(newNode);
          currentOutlineNode = newNode;
        }
      }
    }
    const stripParentProperty = (node) => {
      node.parent = void 0;
      for (const child of node.children)
        stripParentProperty(child);
    };
    stripParentProperty(root);
    return root.children;
  }, tags, tags.map((titleItem) => `${preSelector}${titleItem}`).join(","));
}
function addRefsForOutlineItems(outlines, context, parentRef) {
  return outlines.map((item) => {
    const itemRef = context.nextRef();
    return {
      ...item,
      ref: itemRef,
      parentRef,
      children: addRefsForOutlineItems(item.children, context, itemRef)
    };
  });
}
function countChildrenOfOutline(outlines) {
  let count = 0;
  for (const item of outlines) {
    ++count;
    count += countChildrenOfOutline(item.children);
  }
  return count;
}
function buildPdfObjectsForOutline(outlinesWithRef, context) {
  for (const [i, item] of outlinesWithRef.entries()) {
    const prev = outlinesWithRef[i - 1];
    const next = outlinesWithRef[i + 1];
    const pdfObject = /* @__PURE__ */ new Map([]);
    pdfObject.set(PDFName.of("Title"), PDFHexString.fromText(decode(item.title)));
    pdfObject.set(PDFName.of("Dest"), PDFName.of(item.destination));
    pdfObject.set(PDFName.of("Parent"), item.parentRef);
    pdfObject.set(PDFName.of("F"), PDFNumber.of((item.italic ? 1 : 0) | (item.bold ? 2 : 0)));
    if (Array.isArray(item.color)) {
      const pdfArr = PDFArray.withContext(context);
      pdfArr.push(PDFNumber.of(item.color[0] ?? 0));
      pdfArr.push(PDFNumber.of(item.color[1] ?? 0));
      pdfArr.push(PDFNumber.of(item.color[2] ?? 0));
      pdfObject.set(PDFName.of("C"), pdfArr);
    }
    if (prev)
      pdfObject.set(PDFName.of("Prev"), prev.ref);
    if (next)
      pdfObject.set(PDFName.of("Next"), next.ref);
    if (item.children.length > 0) {
      pdfObject.set(PDFName.of("First"), item.children[0].ref);
      pdfObject.set(PDFName.of("Last"), item.children[item.children.length - 1].ref);
      pdfObject.set(PDFName.of("Count"), PDFNumber.of(countChildrenOfOutline(item.children)));
    }
    context.assign(item.ref, PDFDict.fromMapWithContext(pdfObject, context));
    buildPdfObjectsForOutline(item.children, context);
  }
}
function generateWarningsAboutMissingDestinations(layer, pdfDoc) {
  const dests = pdfDoc.context.lookup(pdfDoc.catalog.get(PDFName.of("Dests")), PDFDict);
  if (dests) {
    const validDestinationTargets = dests.entries().map(([key]) => key.asString());
    for (const item of layer) {
      if (item.destination && !validDestinationTargets.includes(`/${item.destination}`))
        console.warn(`Unable to find destination "${item.destination}" while generating PDF outline.`);
      generateWarningsAboutMissingDestinations(item.children, pdfDoc);
    }
  }
}
async function setOutline(pdfDoc, outlines, enableWarnings = false) {
  const context = pdfDoc.context;
  const rootOutlineRef = context.nextRef();
  if (!outlines.length)
    return pdfDoc;
  if (enableWarnings)
    generateWarningsAboutMissingDestinations(outlines, pdfDoc);
  const outlinesWithRef = addRefsForOutlineItems(outlines, context, rootOutlineRef);
  buildPdfObjectsForOutline(outlinesWithRef, context);
  const outlineObject = /* @__PURE__ */ new Map([]);
  outlineObject.set(PDFName.of("Type"), PDFName.of("Outlines"));
  outlineObject.set(PDFName.of("First"), outlinesWithRef[0].ref);
  outlineObject.set(PDFName.of("Last"), outlinesWithRef[outlinesWithRef.length - 1].ref);
  outlineObject.set(PDFName.of("Count"), PDFNumber.of(countChildrenOfOutline(outlinesWithRef)));
  context.assign(rootOutlineRef, PDFDict.fromMapWithContext(outlineObject, context));
  pdfDoc.catalog.set(PDFName.of("Outlines"), rootOutlineRef);
  return pdfDoc;
}

export {
  formatOutlineContainerSelector,
  getOutline,
  setOutline
};

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/core/outline.ts
var outline_exports = {};
__export(outline_exports, {
  formatOutlineContainerSelector: () => formatOutlineContainerSelector,
  getOutline: () => getOutline,
  setOutline: () => setOutline
});
module.exports = __toCommonJS(outline_exports);
var import_html_entities = require("html-entities");
var import_pdf_lib = require("pdf-lib");
function formatOutlineContainerSelector(outlineContainerSelector) {
  if (!outlineContainerSelector)
    return "";
  const selectors = outlineContainerSelector.split(/\s+/);
  const validSelectors = selectors.filter((selector) => selector);
  const formattedSelector = `${validSelectors.join(" ")} `;
  return formattedSelector;
}
async function getOutline(page, tags, outlineContainerSelector = "") {
  const preSelector = formatOutlineContainerSelector(outlineContainerSelector);
  return await page.evaluate((tags2, outlineSelector) => {
    const tagsToProcess = Array.from(document.querySelectorAll(outlineSelector)).reverse();
    const root = { children: [], depth: -1, parent: void 0 };
    let currentOutlineNode = root;
    const linkHolder = document.createElement("div");
    const body = document.querySelector("body");
    linkHolder.style.display = "none";
    body?.insertBefore(linkHolder, body.firstChild);
    while (tagsToProcess.length > 0) {
      const tag = tagsToProcess.pop();
      const orderDepth = tags2.indexOf(tag.tagName.toLowerCase());
      const dest = encodeURIComponent(tag.id);
      const hiddenLink = document.createElement("a");
      hiddenLink.href = `#${dest}`;
      linkHolder.appendChild(hiddenLink);
      if (orderDepth < currentOutlineNode.depth) {
        currentOutlineNode = currentOutlineNode.parent;
        tagsToProcess.push(tag);
      } else {
        const newNode = {
          // https://stackoverflow.com/questions/57551589/property-innertext-does-not-exist-on-type-element
          title: tag.innerText.trim(),
          destination: dest,
          children: [],
          depth: orderDepth,
          parent: void 0
        };
        if (orderDepth === currentOutlineNode.depth) {
          if (currentOutlineNode.parent) {
            newNode.parent = currentOutlineNode.parent;
            currentOutlineNode.parent.children.push(newNode);
          } else {
            newNode.parent = currentOutlineNode;
            currentOutlineNode.children.push(newNode);
          }
          currentOutlineNode = newNode;
        } else if (orderDepth > currentOutlineNode.depth) {
          newNode.parent = currentOutlineNode;
          currentOutlineNode.children.push(newNode);
          currentOutlineNode = newNode;
        }
      }
    }
    const stripParentProperty = (node) => {
      node.parent = void 0;
      for (const child of node.children)
        stripParentProperty(child);
    };
    stripParentProperty(root);
    return root.children;
  }, tags, tags.map((titleItem) => `${preSelector}${titleItem}`).join(","));
}
function addRefsForOutlineItems(outlines, context, parentRef) {
  return outlines.map((item) => {
    const itemRef = context.nextRef();
    return {
      ...item,
      ref: itemRef,
      parentRef,
      children: addRefsForOutlineItems(item.children, context, itemRef)
    };
  });
}
function countChildrenOfOutline(outlines) {
  let count = 0;
  for (const item of outlines) {
    ++count;
    count += countChildrenOfOutline(item.children);
  }
  return count;
}
function buildPdfObjectsForOutline(outlinesWithRef, context) {
  for (const [i, item] of outlinesWithRef.entries()) {
    const prev = outlinesWithRef[i - 1];
    const next = outlinesWithRef[i + 1];
    const pdfObject = /* @__PURE__ */ new Map([]);
    pdfObject.set(import_pdf_lib.PDFName.of("Title"), import_pdf_lib.PDFHexString.fromText((0, import_html_entities.decode)(item.title)));
    pdfObject.set(import_pdf_lib.PDFName.of("Dest"), import_pdf_lib.PDFName.of(item.destination));
    pdfObject.set(import_pdf_lib.PDFName.of("Parent"), item.parentRef);
    pdfObject.set(import_pdf_lib.PDFName.of("F"), import_pdf_lib.PDFNumber.of((item.italic ? 1 : 0) | (item.bold ? 2 : 0)));
    if (Array.isArray(item.color)) {
      const pdfArr = import_pdf_lib.PDFArray.withContext(context);
      pdfArr.push(import_pdf_lib.PDFNumber.of(item.color[0] ?? 0));
      pdfArr.push(import_pdf_lib.PDFNumber.of(item.color[1] ?? 0));
      pdfArr.push(import_pdf_lib.PDFNumber.of(item.color[2] ?? 0));
      pdfObject.set(import_pdf_lib.PDFName.of("C"), pdfArr);
    }
    if (prev)
      pdfObject.set(import_pdf_lib.PDFName.of("Prev"), prev.ref);
    if (next)
      pdfObject.set(import_pdf_lib.PDFName.of("Next"), next.ref);
    if (item.children.length > 0) {
      pdfObject.set(import_pdf_lib.PDFName.of("First"), item.children[0].ref);
      pdfObject.set(import_pdf_lib.PDFName.of("Last"), item.children[item.children.length - 1].ref);
      pdfObject.set(import_pdf_lib.PDFName.of("Count"), import_pdf_lib.PDFNumber.of(countChildrenOfOutline(item.children)));
    }
    context.assign(item.ref, import_pdf_lib.PDFDict.fromMapWithContext(pdfObject, context));
    buildPdfObjectsForOutline(item.children, context);
  }
}
function generateWarningsAboutMissingDestinations(layer, pdfDoc) {
  const dests = pdfDoc.context.lookup(pdfDoc.catalog.get(import_pdf_lib.PDFName.of("Dests")), import_pdf_lib.PDFDict);
  if (dests) {
    const validDestinationTargets = dests.entries().map(([key]) => key.asString());
    for (const item of layer) {
      if (item.destination && !validDestinationTargets.includes(`/${item.destination}`))
        console.warn(`Unable to find destination "${item.destination}" while generating PDF outline.`);
      generateWarningsAboutMissingDestinations(item.children, pdfDoc);
    }
  }
}
async function setOutline(pdfDoc, outlines, enableWarnings = false) {
  const context = pdfDoc.context;
  const rootOutlineRef = context.nextRef();
  if (!outlines.length)
    return pdfDoc;
  if (enableWarnings)
    generateWarningsAboutMissingDestinations(outlines, pdfDoc);
  const outlinesWithRef = addRefsForOutlineItems(outlines, context, rootOutlineRef);
  buildPdfObjectsForOutline(outlinesWithRef, context);
  const outlineObject = /* @__PURE__ */ new Map([]);
  outlineObject.set(import_pdf_lib.PDFName.of("Type"), import_pdf_lib.PDFName.of("Outlines"));
  outlineObject.set(import_pdf_lib.PDFName.of("First"), outlinesWithRef[0].ref);
  outlineObject.set(import_pdf_lib.PDFName.of("Last"), outlinesWithRef[outlinesWithRef.length - 1].ref);
  outlineObject.set(import_pdf_lib.PDFName.of("Count"), import_pdf_lib.PDFNumber.of(countChildrenOfOutline(outlinesWithRef)));
  context.assign(rootOutlineRef, import_pdf_lib.PDFDict.fromMapWithContext(outlineObject, context));
  pdfDoc.catalog.set(import_pdf_lib.PDFName.of("Outlines"), rootOutlineRef);
  return pdfDoc;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  formatOutlineContainerSelector,
  getOutline,
  setOutline
});

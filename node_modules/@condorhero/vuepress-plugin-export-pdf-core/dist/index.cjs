'use strict';

const runner = require('./runner.cjs');
const generatePdf = require('./shared/vuepress-plugin-export-pdf-core.36e76842.cjs');
const semver = require('semver');
const node_path = require('node:path');
const fse = require('fs-extra');
const pc = require('picocolors');
const bundleRequire = require('bundle-require');
const systemInfo = require('./systemInfo.cjs');
require('cac');
require('html-export-pdf-cli');
require('multimatch');
require('@condorhero/merge-pdfs');
require('pdfjs');
require('envinfo');
require('ora');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const semver__default = /*#__PURE__*/_interopDefaultCompat(semver);
const fse__default = /*#__PURE__*/_interopDefaultCompat(fse);
const pc__default = /*#__PURE__*/_interopDefaultCompat(pc);

const options = {
  year: "numeric",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit",
  hour12: false
};
function timeTransformer(timestamp = /* @__PURE__ */ new Date(), lang = "zh-CN", dateOptions = options) {
  return new Date(timestamp).toLocaleString(lang, dateOptions).replaceAll(/(\/|\:|)/g, "").replace(/\s/, "-");
}

function checkEnv(appName, nodeVersion, appVersion, peerVersion) {
  if (!semver__default.satisfies(process.version, nodeVersion, { includePrerelease: true })) {
    console.error(
      `
[${appName}] minimum Node version not met:
You are using Node ${process.version}, but ${appName} requires Node ${nodeVersion}.
Please upgrade your Node version.
`
    );
    process.exit(1);
  }
  if (!semver__default.satisfies(appVersion, peerVersion, { includePrerelease: true })) {
    console.error(
      `
[${appName}] version not met:
You are using ${appName} ${appVersion}, but plugin requires ${peerVersion}.
Please check it.
`
    );
    process.exit(1);
  }
}

const resolveUserConfigConventionalPath = (source, configName = "vuepress", cwd = process.cwd()) => [
  node_path.resolve(cwd, `${configName}-pdf.config.ts`),
  node_path.resolve(cwd, `${configName}-pdf.config.js`),
  node_path.resolve(cwd, `${configName}-pdf.config.cjs`),
  node_path.resolve(cwd, `${configName}-pdf.config.mjs`),
  node_path.resolve(source, `.${configName}/${configName}-pdf.config.ts`),
  node_path.resolve(source, `.${configName}/${configName}-pdf.config.js`),
  node_path.resolve(source, `.${configName}/${configName}-pdf.config.cjs`),
  node_path.resolve(source, `.${configName}/${configName}-pdf.config.mjs`)
].find((item) => fse__default.pathExistsSync(item));

const resolveUserConfigPath = (userConfigPath, cwd = process.cwd()) => {
  const configPath = node_path.resolve(cwd, userConfigPath);
  if (!fse__default.pathExistsSync(configPath)) {
    throw console.error(
      `config file does not exist: ${pc__default.magenta(userConfigPath)}`
    );
  }
  return configPath;
};

const loadModule = async (configPath) => {
  const { mod } = await bundleRequire.bundleRequire({
    filepath: configPath
  });
  return mod.default || mod;
};

exports.afterParse = runner.afterParse;
exports.beforeParse = runner.beforeParse;
exports.runCli = runner.runCli;
exports.filterRoute = generatePdf.filterRoute;
exports.generatePdf = generatePdf.generatePdf;
exports.mergePDF = generatePdf.mergePDF;
exports.systemInfo = systemInfo.systemInfo;
exports.checkEnv = checkEnv;
exports.loadModule = loadModule;
exports.resolveUserConfigConventionalPath = resolveUserConfigConventionalPath;
exports.resolveUserConfigPath = resolveUserConfigPath;
exports.timeTransformer = timeTransformer;
